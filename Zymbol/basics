#
# Adapted from Calendrical Calculations by
# Edward M. Reingold and Nachum Dershowitz
#

#
# 1.17
# The book uses a different definition of mod function:
# x mod y ::= x - y * floor(x/y)
#
function mod(x, y) {
    # Handle special case y == 1 for better accuracy
    if (y == 1) {
        x - floor(x)
    } else {
        x - y * floor(x / y)
    }
}

Calendar->Epoch = 0                 # 1.1

#
# Rata Die / Fixed Date
# 1.1
#
function rd(t) {
    t - Calendar->Epoch
}

Calendar->JD_Epoch = rd(-1721424.5) # 1.3 Julian date epoch
Calendar->MJD_Epoch = rd(678576)    # 1.6 Modified Julian Epoch
Calendar->UNIX_Epoch = rd(719163)   # 1.9 Unix Epoch

#
# 1.4
#
function moment_from_jd(jd) {
    jd + Calendar->JD_Epoch
}

#
# 1.5
#
function jd_from_moment(t) {
    t - Calendar->JD_Epoch
}

#
# 1.7
#
function fixed_from_mjd(mjd) {
    mjd + Calendar->MJD_Epoch
}

#
# 1.8
#
function mjd_from_fixed(date) {
    date - Calendar->MJD_Epoch
}

#
# 1.10
#
function moment_from_unix(seconds) {
    Calendar->UNIX_Epoch + seconds / 24 / 60 / 60
}

#
# 1.11
#
function unix_from_moment(t) {
    24 * 60 * 60 * (t - Calendar->UNIX_Epoch)
}

#
# 1.12
#
function fixed_from_moment(t) {
    floor(t)
}

#
# 1.13
#
function fixed_from_jd(jd) {
    floor(moment_from_jd(jd))
}

#
# 1.14
#
function jd_from_fixed(date) {
    jd_from_moment(date)
}

#
# 1.18
#
function time_from_moment(t) {
    mod(t, 1)
}

#
# 1.22
#
function gcd(x, y) {
    if (y == 0) { 
        x 
    } else { 
        gcd(y, mod(x, y))
    }
}

#
# 1.23
#
function lcm(x, y) {
    x * y / gcd(x, y)
}

#
# 1.24
# This is a modified mod typeset as x mod [a .. b) in the book.
#
# x mod [a .. b) ::= 
#     x                     if a == b;
#     a + (x-a) mod (b-a)   otherwise
#
function mod2(x, a, b) {
    if (a == b) {
        x
    } else {
        a + mod(x - a, b - a)
    }
}

#
# 1.28
# This is a modified mod typeset as x mod [1 .. b] in the book.
#
# x mod [1 .. b] ::=
#     b                 if x mod b == 0
#     x mod b           otherwise
#
function mod3(x, b) {
    variable n = mod(x, b)
    if (n == 0) {
        b
    } else {
        n
    }
}

#
# 1.30
# Conditional summation will sum f(i) starting from i = k 
# as long as p(i) is true.
#
function sum_if(f, p, k) {
    variable i = k, result = 0 
    while (p(i)) {
        result = result + f(i)
        i = i + 1
    }
    result
}

#
# 1.31
# Conditional multiplication analogous to 1.30 above.
# Multiply f(i) as long as p(i) is true.
#
function multiply_if(f, p, k) {
    variable i = k, result = 1
    while (p(i)) {
        result = result * f(i)
        i = i + 1
    }
    result
}

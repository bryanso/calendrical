#
# Adapted from Calendrical Calculations: The Ultimate Edition
# Edward M. Reingold and Nachum Dershowitz
#

#
# 1.17
# The book uses a different definition of mod function:
# x mod y ::= x - y * floor(x/y)
#
function mod(x, y) {
    # Handle special case y == 1 for better accuracy
    if (y == 1) {
        x - floor(x)
    } else {
        x - y * floor(x / y)
    }
}

Calendar->Sunday = 0                # 1.53
Calendar->Monday = 1                # 1.54
Calendar->Tuesday = 2               # 1.55
Calendar->Wednesday = 3             # 1.56
Calendar->Thursday = 4              # 1.57
Calendar->Friday = 5                # 1.58
Calendar->Saturday = 6              # 1.59

Calendar->January = 1               # 2.4
Calendar->February = 2              # 2.5
Calendar->March = 3                 # 2.6
Calendar->April = 4                 # 2.7
Calendar->May = 5                   # 2.8
Calendar->June = 6                  # 2.9
Calendar->July = 7                  # 2.10
Calendar->August = 8                # 2.11
Calendar->September = 9             # 2.12
Calendar->October = 10              # 2.13
Calendar->November = 11             # 2.14
Calendar->December = 12             # 2.15

Calendar->Epoch = 0                 # 1.1

#
# Rata Die / Fixed Date
# 1.1
#
function rd(t) {
    t - Calendar->Epoch
}

Calendar->JD_Epoch = rd(-1721424.5) # 1.3 Julian date epoch
Calendar->MJD_Epoch = rd(678576)    # 1.6 Modified Julian Epoch
Calendar->UNIX_Epoch = rd(719163)   # 1.9 Unix Epoch

#
# 1.4
#
function moment_from_jd(jd) {
    jd + Calendar->JD_Epoch
}

#
# 1.5
#
function jd_from_moment(t) {
    t - Calendar->JD_Epoch
}

#
# 1.7
#
function fixed_from_mjd(mjd) {
    mjd + Calendar->MJD_Epoch
}

#
# 1.8
#
function mjd_from_fixed(date) {
    date - Calendar->MJD_Epoch
}

#
# 1.10
#
function moment_from_unix(seconds) {
    Calendar->UNIX_Epoch + seconds / 24 / 60 / 60
}

#
# 1.11
#
function unix_from_moment(t) {
    24 * 60 * 60 * (t - Calendar->UNIX_Epoch)
}

#
# 1.12
#
function fixed_from_moment(t) {
    floor(t)
}

#
# 1.13
#
function fixed_from_jd(jd) {
    floor(moment_from_jd(jd))
}

#
# 1.14
#
function jd_from_fixed(date) {
    jd_from_moment(date)
}

#
# 1.18
#
function time_from_moment(t) {
    mod(t, 1)
}

#
# 1.22
#
function gcd(x, y) {
    if (y == 0) { 
        x 
    } else { 
        gcd(y, mod(x, y))
    }
}

#
# 1.23
#
function lcm(x, y) {
    x * y / gcd(x, y)
}

#
# 1.24
# This is a modified mod typeset as x mod [a .. b) in the book.
#
# x mod [a .. b) ::= 
#     x                     if a == b;
#     a + (x-a) mod (b-a)   otherwise
#
function mod2(x, a, b) {
    if (a == b) {
        x
    } else {
        a + mod(x - a, b - a)
    }
}

#
# 1.28
# This is a modified mod typeset as x mod [1 .. b] in the book.
#
# x mod [1 .. b] ::=
#     b                 if x mod b == 0
#     x mod b           otherwise
#
function mod3(x, b) {
    variable n = mod(x, b)
    if (n == 0) {
        b
    } else {
        n
    }
}

#
# 1.30
# Conditional summation will sum f(i) starting from i = k 
# as long as p(i) is true.
#
function sum_if(f, p, k) {
    variable i = k, result = 0 
    while p(i) {
        result = result + f(i)
        i = i + 1
    }
    result
}

#
# 1.31
# Conditional multiplication analogous to 1.30 above.
# Multiply f(i) as long as p(i) is true.
#
function multiply_if(f, p, k) {
    variable i = k, result = 1
    while p(i) {
        result = result * f(i)
        i = i + 1
    }
    result
}

#
# 1.32
# MIN search searches for the smallest d in the sequence d0, d0+1, ...
# such that the condition p holds true for d.  The caller must make
# sure this function will terminate for some d.  Return d.
#
function min_search(p, d0) {
    while not p(d0) {
        d0 = d0 + 1
    }
    d0
}

#
# 1.33
# MAX search is the compliment of MIN search.  It returns d such
# that p(d0), p(d0+1), ... p(d) are true but the next one p(d+1) is
# false.  Return d.  If p(d0) is already false, return d0-1.
# The caller must make sure this function will terminate.
#
function max_search(p, d0) {
    while p(d0) {
        d0 = d0 + 1
    }
    d0 - 1
}

#
# 1.34
# This ia generic binary search algorithm that can be adapted to perform
# any searches for answers to some increasing function.  
#
# Supposed we want to find x where some function f(x) = y
#
# q(l, u) is an accuracy test, e.g. u - l < 0.0001
# [a, b] is the initial guess interval
# p is a boolean test function that is false within the range [a, x) and
# turns true in the range [x, b]
#
# E.g., To use it to find x that satisifies f(x) = y where f is an
# increasing function and x has accuracy to 4 decimal digits and
# x is known to be between [0, 1] can be:
#
# min_binary_search(
#    function (l, u) { (u - l) < 0.0001 },
#    0,    
#    1,
#    function (x) { f(x) >= y }
# )   
#   
function min_binary_search(q, a, b, p) {
    variable x = (a + b) / 2   # mid-point
    if q(a, b) {
        x
    } else if p(x) {
        min_binary_search(q, a, x, p)
    } else {
        min_binary_search(q, x, b, p)
    }
}

#
# 1.37
#
function list_of_fixed_from_moments(l) {
    mapcar(l fixed_from_moment)
}

#
# 1.40
#
# To collect all occurrence of events, such as holidays, in an interval time,
# like a Gregorian year, we write a generic function to find the first occurrence on
# or after a given moment of the p-th moment in a c-day cycle, 0 <= p < c, and then
# recursively find the remaining occurrences:
#
# positions-in-range(p, c, d, [a .. b)) ::=
#     {}                                                 // if  date >= b
#     {date} || positions-in-range(p, c, d, [a+c .. b))  // otherwise
#
# where date = (p - d) mod [a .. a+c)                    // mod2
#
function positions_in_range(p, c, d, a, b) {
    variable date = mod2(p - d, a, a + c)
    if date >= b {
        {}
    } else {
        {date} & positions_in_range(p, c, d, a + c, b)
    }
}

#
# 1.41
# Evaluate mixed-radix number 
#
# a = { a0 a1 a2 ... an }
#
# written in base
#
# b = { b1 b2 ... bk } || { bk+1 bk+2 ... bn }   // starting from bk+1 it's decimal places
#
# Notice length of b is one less than length of a.
#
function radix(a, b, d) {
    variable n = length(a)
    if n == 0 {
        return 0
    }

    variable result = a[n]  # Start backwards
    n = n - 1

    # Decimal places need division
    for k = length(d) to 1 by -1 {
        result = a[n] + result / d[k]
        n = n - 1
    }

    variable factor = 1
    # Start multiplicative bases
    for k = length(b) to 1 by -1 {
        factor = factor * b[k]
        result = result + a[n] * factor
        n = n - 1
    }

    # Test cases
    # ♠ radix({0 4 48 0}, {}, {24, 60, 60})
    # 0.19999999999999998
    # ♠ radix({4 1 12 44 2.88} {7} {24 60 60})
    # 29.53058888888889

    result
}

#
# 1.42 (Reverse of 1.41)
#
function radix2(x, b, d) {
    variable a = {}
    variable factor = 1
    variable t
    for k = 1 to length(d) {
        factor = factor * d[k]
        if k == length(d) {
            t = mod(x * factor, d[k])
        } else {
            t = mod(floor(x * factor), d[k])
        }
        a = a & {t}
    }

    factor = 1
    for k = length(b) to 1 by -1 {
        t = mod(floor(x / factor), b[k])
        a = {t} & a
        factor = factor * b[k]
    }

    # a0
    {floor(x / factor)} & a
}

#
# 1.43
#
# Definition in the book is incorrect.  The following should be the
# corrected version.  But it's more readable to use the 3rd ed. formula.
#
# function time_from_clock(hms) {
#    radix({0} & hms, {}, {24, 60, 60}) 
# }
#
# Formula from 3rd edition
#
function time_from_clock(hms) {
    variable h = hms[1]
    variable m = hms[2]
    variable s = hms[3]
    (h + (m + s / 60) / 60) / 24
}

#
# 1.44
#
# Formula from 3rd edition
#
# function clock_from_moment(t) {
#     variable h, m, s
#     variable time = time_from_moment(t)
#     h = floor(time * 24)
#     m = floor(mod(time * 24 * 60, 60))
#     s = mod(time * 24 * 60 * 60, 60)
#     {h m s}
# }
#
function clock_from_moment(t) {
    rest(radix2(t, {}, {24 60 60}))
}

#
# 1.45
# 
function angle_from_degrees(a) {
    variable dms = radix2(abs(a), {}, {60 60})
    if a >= 0 {
        dms
    } else {
        {-dms[1], -dms[2], -dms[3]}
    }
}

#
# 1.46
#
Calendar->Egyptian_Epoch = fixed_from_jd(1448638)

#
# The Egyptian Months
#
#  1. Thoth                  30 days
#  2. Phaophi                30 days
#  3. Athyr                  30 days
#  4. Choiak                 30 days
#  5. Tybi                   30 days
#  6. Mechir                 30 days
#  7. Phamenoth              30 days
#  8. Pharmuthi              30 days
#  9. Pachon                 30 days
# 10. Payni                  30 days
# 11. Epiphi                 30 days
# 12. Mesori                 30 days
# 13. (unnamed epagomenae)    5 days
#

#
# 1.47
#
function fixed_from_egyptian(year, month, day) {
    Calendar->Egyptian_Epoch + 
        365 * (year - 1) +
        30 * (month - 1) + 
        day - 1
}

#
# 1.49
#
function egyptian_from_fixed(date) {
    variable days, year, month, day
    days = date - Calendar->Egyptian_Epoch
    year = floor(days / 365) + 1
    month = floor(mod(days, 365) / 30) + 1
    day = days - 365 * (year - 1) - 30 * (month - 1) + 1
    {year month day}
}

#
# 1.50
#
Calendar->Armenian_Epoch = rd(201443)

#
# The Armenian Months
#
#  1. Nawasardi              30 days
#  2. Hori                   30 days
#  3. Sahmi                  30 days
#  4. Tre                    30 days
#  5. K'aloch                30 days
#  6. Arach                  30 days
#  7. Mehekani               30 days
#  8. Areg                   30 days
#  9. Ahekani                30 days
# 10. Mareri                 30 days
# 11. Margach                30 days
# 12. Hrotich                30 days
# 13. aweleach                5 days
#

#
# 1.51
#
function fixed_from_armenian(year, month, day) {
    Calendar->Armenian_Epoch + 
        fixed_from_egyptian(year, month, day) -
        Calendar->Egyptian_Epoch
}

#
# 1.52
#
function armenian_from_fixed(date) {
    egyptian_from_fixed(date + Calendar->Egyptian_Epoch - Calendar->Armenian_Epoch)
}

# 1.60
function day_of_week_from_fixed(date) {
    mod(date - rd(0) - Calendar->Sunday, 7)
}

# 1.62
function kday_on_or_before(k, date) {
    date - day_of_week_from_fixed(date - k)
}

# 1.65
function kday_on_or_after(k, date) {
    kday_on_or_before(k, date + 6)
}

# 1.66
function kday_nearest(k, date) {
    kday_on_or_before(k, date + 3)
}

# 1.67
function kday_before(k, date) {
    kday_on_or_before(k, date - 1)
}

# 1.68
function kday_after(k, date) {
    kday_on_or_before(k, date + 7)
}

#
# Section 1.13 Simultaneous Cycles
#
# Some calendars employ two cycles running simultaneously.
# Each day is labeled by a pair of number <a, b>, beginning
# with <0, 0>, followed by <1, 1>, <2, 2>, and so on.
# Supposed the first component repeats after c days and the
# second after d days, with c < d < 2c, then after day
# <c-1, c-1> comes days <0, c>, <1, c+1>, and so on until
# <d-c-1, d-1>, which is followed by <d-c, 0>.  If day 0 of
# the calendar is labeled <0, 0> then day n is <mod(n, c),
# mod(n, d)>.  The Chinese use such pairs to identify years
# (see Section 19.4), which cycles of length c = 10 and
# d = 12 but, because the first component ranges from 1 to
# 10, inclusive, and the second from 1 to 12, we would use
# the adjusted remainder function: <mod3(n, 10), mod3(n, 12)
#
# More generally, for arbitrary positive integers c and d,
# if the label of day 0 is <e, f> then day n is labeled
#
# <mod(n+ , c), mod(n+f, d)>
#
# Inverting this representation is harder.
#
# Let 
#     l = lcm(c, d)
#     g = gcd(c, d)
#     u = c / g
#     v = d / g
#  
# Find k so that
#     mod(k * u, v) = 1
#
# n = mod(a - e + c * k * (b - a + e - f) / g, l)
#

#
# The prefixes of the Akan calendar are
#
# 1 Nwona (care, wellness, surpass, innocence)
# 2 Nkyi (passing, no restrictions)
# 3 Kuru (sacred, complete)
# 4 Kwa (ordinary, empty, freedom)
# 5 Mono (fresh, new)
# 6 Fo (generous, calm, love to another)
#
# The stems are
#
# 1 Wukuo (cleansing, advocate, mean-spirited)
# 2 Yaw (pain, suffering, bravery)
# 3 Fie (depart from, come forth, travel)
# 4 Memene (digest, satiety, creation, ancient)
# 5 Kwasi (freedom, purify, smoke)
# 6 Dwo (peaceful, cool, calm)
# 7 Bene (well-cooked)
# 

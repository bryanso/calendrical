#
# Adapted from Calendrical Calculations by
# Edward M. Reingold and Nachum Dershowitz
#

#
# 1.17
# The book uses a different definition of mod function:
# x mod y ::= x - y * floor(x/y)
#
function mod(x, y) {
    # Handle special case y == 1 for better accuracy
    if (y == 1) {
        x - floor(x)
    } else {
        x - y * floor(x / y)
    }
}

Calendar->Epoch = 0                 # 1.1

#
# Rata Die / Fixed Date
# 1.1
#
function rd(t) {
    t - Calendar->Epoch
}

Calendar->JD_Epoch = rd(-1721424.5) # 1.3 Julian date epoch
Calendar->MJD_Epoch = rd(678576)    # 1.6 Modified Julian Epoch
Calendar->UNIX_Epoch = rd(719163)   # 1.9 Unix Epoch

#
# 1.4
#
function moment_from_jd(jd) {
    jd + Calendar->JD_Epoch
}

#
# 1.5
#
function jd_from_moment(t) {
    t - Calendar->JD_Epoch
}

#
# 1.7
#
function fixed_from_mjd(mjd) {
    mjd + Calendar->MJD_Epoch
}

#
# 1.8
#
function mjd_from_fixed(date) {
    date - Calendar->MJD_Epoch
}

#
# 1.10
#
function moment_from_unix(seconds) {
    Calendar->UNIX_Epoch + seconds / 24 / 60 / 60
}

#
# 1.11
#
function unix_from_moment(t) {
    24 * 60 * 60 * (t - Calendar->UNIX_Epoch)
}

#
# 1.12
#
function fixed_from_moment(t) {
    floor(t)
}

#
# 1.13
#
function fixed_from_jd(jd) {
    floor(moment_from_jd(jd))
}

#
# 1.14
#
function jd_from_fixed(date) {
    jd_from_moment(date)
}

#
# 1.18
#
function time_from_moment(t) {
    mod(t, 1)
}

#
# 1.22
#
function gcd(x, y) {
    if (y == 0) { 
        x 
    } else { 
        gcd(y, mod(x, y))
    }
}

#
# 1.23
#
function lcm(x, y) {
    x * y / gcd(x, y)
}

#
# 1.24
# This is a modified mod typeset as x mod [a .. b) in the book.
#
# x mod [a .. b) ::= 
#     x                     if a == b;
#     a + (x-a) mod (b-a)   otherwise
#
function mod2(x, a, b) {
    if (a == b) {
        x
    } else {
        a + mod(x - a, b - a)
    }
}

#
# 1.28
# This is a modified mod typeset as x mod [1 .. b] in the book.
#
# x mod [1 .. b] ::=
#     b                 if x mod b == 0
#     x mod b           otherwise
#
function mod3(x, b) {
    variable n = mod(x, b)
    if (n == 0) {
        b
    } else {
        n
    }
}

#
# 1.30
# Conditional summation will sum f(i) starting from i = k 
# as long as p(i) is true.
#
function sum_if(f, p, k) {
    variable i = k, result = 0 
    while p(i) {
        result = result + f(i)
        i = i + 1
    }
    result
}

#
# 1.31
# Conditional multiplication analogous to 1.30 above.
# Multiply f(i) as long as p(i) is true.
#
function multiply_if(f, p, k) {
    variable i = k, result = 1
    while p(i) {
        result = result * f(i)
        i = i + 1
    }
    result
}

#
# 1.32
# MIN search searches for the smallest d in the sequence d0, d0+1, ...
# such that the condition p holds true for d.  The caller must make
# sure this function will terminate for some d.  Return d.
#
function min_search(p, d0) {
    while not p(d0) {
        d0 = d0 + 1
    }
    d0
}

#
# 1.33
# MAX search is the compliment of MIN search.  It returns d such
# that p(d0), p(d0+1), ... p(d) are true but the next one p(d+1) is
# false.  Return d.  If p(d0) is already false, return d0-1.
# The caller must make sure this function will terminate.
#
function max_search(p, d0) {
    while p(d0) {
        d0 = d0 + 1
    }
    d0 - 1
}

#
# 1.34
# This ia generic binary search algorithm that can be adapted to perform
# any searches for answers to some increasing function.  
#
# Supposed we want to find x where some function f(x) = y
#
# q(l, u) is an accuracy test, e.g. u - l < 0.0001
# [a, b] is the initial guess interval
# p is a boolean test function that is false within the range [a, x) and
# turns true in the range [x, b]
#
# E.g., To use it to find x that satisifies f(x) = y where f is an
# increasing function and x has accuracy to 4 decimal digits and
# x is known to be between [0, 1] can be:
#
# min_binary_search(
#    function (l, u) { (u - l) < 0.0001 },
#    0,    
#    1,
#    function (x) { f(x) >= y }
# )   
#   
function min_binary_search(q, a, b, p) {
    variable x = (a + b) / 2   # mid-point
    if q(a, b) {
        x
    } else if p(x) {
        min_binary_search(q, a, x, p)
    } else {
        min_binary_search(q, x, b, p)
    }
}

#
# 1.37
#
function list_of_fixed_from_moments(l) {
    mapcar(l fixed_from_moment)
}

#
# 1.40
#
# To collect all occurrence of events, such as holidays, in an interval time,
# like a Gregorian year, we write a generic function to find the first occurrence on
# or after a given moment of the p-th moment in a c-day cycle, 0 <= p < c, and then
# recursively find the remaining occurrences:
#
# positions-in-range(p, c, d, [a .. b)) ::=
#     {}                                                 // if  date >= b
#     {date} || positions-in-range(p, c, d, [a+c .. b))  // otherwise
#
# where date = (p - d) mod [a .. a+c)                    // mod2
#
function positions_in_range(p, c, d, a, b) {
    variable date = mod2(p - d, a, a + c)
    if date >= b {
        {}
    } else {
        {date} & positions_in_range(p, c, d, a + c, b)
    }
}

function test_pi(x) {
    x >= 3.1415926538
}

function test_accuracy(l, u) {
    (u - l) < 0.001
}

# print min_binary_search(test_accuracy, 0, 10, test_pi)